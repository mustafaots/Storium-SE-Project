# Schema Service

## Purpose
Implements business logic for schema management. Handles pagination, search, validation, data transformation, and orchestrates communication between controllers and models. Manages hierarchical schema structure validation.

## File Locations
- `backend/src/services/locations.service.js`
- `backend/src/services/depots.service.js`
- `backend/src/services/aisles.service.js`
- `backend/src/services/racks.service.js`

---

## LOCATIONS SERVICE

### getAllPaginated(page, limit, search)
Fetches paginated locations with search capability.

**Input Parameters:**
```javascript
page: number = 1           // Page number (1-based, minimum 1)
limit: number = 10         // Items per page (1-10, maximum 100)
search: string = ""        // Search term for name, address, coordinates
```

**Validation Logic:**
```javascript
// Validate page
validatedPage = Math.max(1, parseInt(page))
if (isNaN(validatedPage)) validatedPage = 1

// Validate limit
validatedLimit = Math.min(
  Math.max(1, parseInt(limit)),
  constants.PAGINATION.MAX_LIMIT  // Typically 100
)
if (isNaN(validatedLimit)) validatedLimit = 10

// Trim search
search = search.trim()
```

**SQL Query Generated:**
```sql
-- Without search:
SELECT * FROM locations 
ORDER BY created_at DESC 
LIMIT 10 OFFSET 0;

-- With search (name like '%schema%'):
SELECT * FROM locations
WHERE name LIKE '%schema%' 
   OR address LIKE '%schema%' 
   OR coordinates LIKE '%schema%'
ORDER BY created_at DESC
LIMIT 10 OFFSET 0;
```

**Process Flow:**
```
1. Validate page number (minimum 1)
2. Validate limit (minimum 1, maximum MAX_LIMIT)
3. Trim search term
4. Call Location.getAllPaginated(validatedPage, validatedLimit, search)
5. Call Location.getTotalCount(search) in parallel
6. Calculate pagination metadata:
   - pages = Math.ceil(total / validatedLimit)
7. Return { locations, pagination }
```

**Response Data:**
```javascript
{
  locations: [
    {
      location_id: number,
      name: string,
      address: string,
      coordinates: string,
      created_at: Date | string
    },
    ...
  ],
  pagination: {
    page: number,
    limit: number,
    total: number,        // Total matching records
    pages: number         // Total pages available
  }
}
```

**Error Handling:**
```javascript
// Database error
if (err) throw new Error('Database query failed');

// Invalid pagination parameters
if (page < 1) return error 'Page must be >= 1'
if (limit < 1) return error 'Limit must be >= 1'
```

---

### getById(id)
Fetches a single location by ID.

**Input Parameters:**
```javascript
id: number  // Location ID
```

**SQL Query:**
```sql
SELECT * FROM locations WHERE location_id = ?;
-- Parameters: [id]
```

**Response Data:**
```javascript
Location = {
  location_id: number,
  name: string,
  address: string,
  coordinates: string,
  created_at: Date
} | undefined  // undefined if not found
```

---

### create(locationData)
Creates a new location.

**Input Parameters:**
```javascript
locationData = {
  name: string,           // Location name (required)
  address: string,        // Full address (required)
  coordinates: string     // Format: "lat,lng" (required)
}
```

**Validation Rules:**
```javascript
// Validate presence
if (!name || !address || !coordinates) 
  throw new Error('name, address, coordinates are required')

// Validate types
if (typeof name !== 'string') 
  throw new Error('name must be string')
if (typeof address !== 'string')
  throw new Error('address must be string')
if (typeof coordinates !== 'string')
  throw new Error('coordinates must be string')

// Validate coordinates format
const coordPattern = /^-?[0-9]+\.?[0-9]*,-?[0-9]+\.?[0-9]*$/
if (!coordPattern.test(coordinates))
  throw new Error('coordinates must be "latitude,longitude" format')
```

**SQL Query:**
```sql
INSERT INTO locations (name, address, coordinates) 
VALUES (?, ?, ?);
-- Parameters: [name, address, coordinates]

-- Auto-generated:
-- location_id: INT AUTO_INCREMENT
-- created_at: TIMESTAMP DEFAULT CURRENT_TIMESTAMP
```

**Response Data:**
```javascript
{
  location_id: number,    // Generated by AUTO_INCREMENT
  name: string,
  address: string,
  coordinates: string,
  created_at: Date        // Set by CURRENT_TIMESTAMP
}
```

---

### update(id, locationData)
Updates an existing location.

**Input Parameters:**
```javascript
id: number
locationData = {
  name: string | undefined,
  address: string | undefined,
  coordinates: string | undefined
}
```

**Validation Logic:**
```javascript
// Check if ID is valid
if (!id || isNaN(id)) throw new Error('Valid ID required')

// Only validate fields that are being updated
const updates = {}
if (locationData.name !== undefined) {
  if (typeof locationData.name !== 'string') 
    throw new Error('name must be string')
  updates.name = locationData.name
}
if (locationData.address !== undefined) {
  if (typeof locationData.address !== 'string')
    throw new Error('address must be string')
  updates.address = locationData.address
}
if (locationData.coordinates !== undefined) {
  if (!coordPattern.test(locationData.coordinates))
    throw new Error('Invalid coordinates format')
  updates.coordinates = locationData.coordinates
}

// Ensure at least one field to update
if (Object.keys(updates).length === 0)
  throw new Error('No fields to update')
```

**SQL Query Generated:**
```sql
-- Dynamic based on provided fields:
UPDATE locations 
SET name = ?, address = ?, coordinates = ? 
WHERE location_id = ?;
-- Parameters: [name, address, coordinates, id]
```

**Response Data:**
```javascript
{
  affectedRows: number,   // 0 if location not found, 1 if updated
  message: string
}
```

---

### delete(id)
Deletes a location with cascading effects.

**Input Parameters:**
```javascript
id: number  // Location ID
```

**Cascade Effects:**
```
DELETE FROM locations WHERE location_id = ?
  ↓
ON DELETE CASCADE triggers:
  ├── DELETE FROM depots WHERE parent_location = ?
  ├── DELETE FROM aisles WHERE parent_depot IN (...)
  ├── DELETE FROM racks WHERE parent_aisle IN (...)
  ├── DELETE FROM rack_slots WHERE rack_id IN (...)
  └── DELETE FROM stocks WHERE slot_id IN (...)
```

**SQL Query:**
```sql
DELETE FROM locations WHERE location_id = ?;
-- Parameters: [id]
```

**Response Data:**
```javascript
{
  affectedRows: number,   // 1 if deleted, 0 if not found
  deletedCount: number    // Total cascade deletions
}
```

---

## DEPOTS SERVICE

### getAllPaginatedByLocation(locationId, page, limit, search)
Fetches depots for a specific location.

**Input Parameters:**
```javascript
locationId: number
page: number = 1
limit: number = 10
search: string = ""
```

**SQL Query:**
```sql
SELECT 
  d.depot_id,
  d.parent_location,
  d.name,
  COUNT(DISTINCT rs.slot_id) as total_slots,
  SUM(CASE WHEN rs.is_occupied = 1 THEN 1 ELSE 0 END) as occupied_slots,
  ROUND(
    (SUM(CASE WHEN rs.is_occupied = 1 THEN 1 ELSE 0 END) / 
     COUNT(DISTINCT rs.slot_id)) * 100
  ) as capacity_utilization,
  d.created_at
FROM depots d
LEFT JOIN aisles a ON d.depot_id = a.parent_depot
LEFT JOIN racks r ON a.aisle_id = r.parent_aisle
LEFT JOIN rack_slots rs ON r.rack_id = rs.rack_id
WHERE d.parent_location = ?
  AND d.name LIKE ?
GROUP BY d.depot_id
ORDER BY d.created_at DESC
LIMIT ? OFFSET ?;
```

**Validation:**
```javascript
// Verify location exists first
const location = await Location.getById(locationId)
if (!location) throw new Error('Parent location not found')

// Validate pagination
validatedPage = Math.max(1, parseInt(page))
validatedLimit = Math.min(Math.max(1, parseInt(limit)), 100)
```

**Response Data:**
```javascript
{
  depots: [
    {
      depot_id: number,
      parent_location: number,
      name: string,
      total_slots: number,
      occupied_slots: number,
      capacity_utilization: number | null,  // Percentage
      created_at: Date
    },
    ...
  ],
  pagination: {
    page: number,
    limit: number,
    total: number,
    pages: number
  }
}
```

---

### createDepot(locationId, depotData)
Creates a new depot in a location.

**Input Parameters:**
```javascript
locationId: number
depotData = {
  name: string  // Depot name (required)
}
```

**Validation Logic:**
```javascript
// Verify parent location exists
const location = await Location.getById(locationId)
if (!location) throw new Error('Parent location not found')

// Validate depot name
if (!depotData.name || typeof depotData.name !== 'string')
  throw new Error('Depot name must be a non-empty string')

if (depotData.name.trim().length === 0)
  throw new Error('Depot name cannot be empty')

// Check for duplicate name in same location
const existing = await Depot.findByLocationAndName(locationId, depotData.name)
if (existing) 
  throw new Error('A depot with this name already exists in this location')
```

**SQL Query:**
```sql
INSERT INTO depots (parent_location, name) 
VALUES (?, ?);
-- Parameters: [locationId, name]

-- Auto-generated:
-- depot_id: INT AUTO_INCREMENT
-- created_at: TIMESTAMP DEFAULT CURRENT_TIMESTAMP
```

**Response Data:**
```javascript
{
  depot_id: number,
  parent_location: number,
  name: string,
  created_at: Date
}
```

---

## AISLES SERVICE

### getAllPaginatedByDepot(depotId, page, limit, search)
Fetches aisles for a specific depot.

**Input Parameters:**
```javascript
depotId: number
page: number = 1
limit: number = 10
search: string = ""
```

**SQL Query:**
```sql
SELECT 
  a.aisle_id,
  a.parent_depot,
  a.name,
  COUNT(DISTINCT r.rack_id) as total_racks,
  ROUND(
    (SUM(CASE WHEN rs.is_occupied = 1 THEN 1 ELSE 0 END) / 
     COUNT(DISTINCT rs.slot_id)) * 100
  ) as capacity_utilization,
  a.created_at
FROM aisles a
LEFT JOIN racks r ON a.aisle_id = r.parent_aisle
LEFT JOIN rack_slots rs ON r.rack_id = rs.rack_id
WHERE a.parent_depot = ?
  AND a.name LIKE ?
GROUP BY a.aisle_id
ORDER BY a.created_at DESC
LIMIT ? OFFSET ?;
```

**Response Data:**
```javascript
{
  aisles: [
    {
      aisle_id: number,
      parent_depot: number,
      name: string,
      total_racks: number,
      capacity_utilization: number | null,
      created_at: Date
    },
    ...
  ],
  pagination: {
    page: number,
    limit: number,
    total: number,
    pages: number
  }
}
```

---

### createAisle(depotId, aisleData)
Creates a new aisle in a depot.

**Input Parameters:**
```javascript
depotId: number
aisleData = {
  name: string  // Aisle name (e.g., "A1", "B2")
}
```

**Validation Logic:**
```javascript
// Verify parent depot exists
const depot = await Depot.getById(depotId)
if (!depot) throw new Error('Parent depot not found')

// Validate aisle name
if (!aisleData.name || typeof aisleData.name !== 'string')
  throw new Error('Aisle name required')

// Check for duplicate in same depot
const existing = await Aisle.findByDepotAndName(depotId, aisleData.name)
if (existing)
  throw new Error('Aisle with this name already exists in depot')
```

**SQL Query:**
```sql
INSERT INTO aisles (parent_depot, name) 
VALUES (?, ?);
-- Parameters: [depotId, name]
```

**Response Data:**
```javascript
{
  aisle_id: number,
  parent_depot: number,
  name: string,
  created_at: Date
}
```

---

## RACKS SERVICE

### getAllPaginatedByAisle(aisleId, page, limit, search)
Fetches racks for a specific aisle.

**Input Parameters:**
```javascript
aisleId: number
page: number = 1
limit: number = 10
search: string = ""
```

**SQL Query:**
```sql
SELECT 
  r.rack_id,
  r.parent_aisle,
  r.rack_code,
  COUNT(DISTINCT rs.slot_id) as total_slots,
  SUM(CASE WHEN rs.is_occupied = 1 THEN 1 ELSE 0 END) as occupied_slots,
  (
    COUNT(DISTINCT rs.slot_id) - 
    SUM(CASE WHEN rs.is_occupied = 1 THEN 1 ELSE 0 END)
  ) as empty_slots,
  ROUND(
    (SUM(CASE WHEN rs.is_occupied = 1 THEN 1 ELSE 0 END) / 
     COUNT(DISTINCT rs.slot_id)) * 100
  ) as capacity_utilization,
  r.created_at
FROM racks r
LEFT JOIN rack_slots rs ON r.rack_id = rs.rack_id
WHERE r.parent_aisle = ?
  AND r.rack_code LIKE ?
GROUP BY r.rack_id
ORDER BY r.rack_code ASC
LIMIT ? OFFSET ?;
```

**Response Data:**
```javascript
{
  racks: [
    {
      rack_id: number,
      parent_aisle: number,
      rack_code: string,
      total_slots: number,
      occupied_slots: number,
      empty_slots: number,
      capacity_utilization: number,
      created_at: Date
    },
    ...
  ],
  pagination: {
    page: number,
    limit: number,
    total: number,
    pages: number
  }
}
```

---

### createRack(aisleId, rackData)
Creates a new rack with calculated slots.

**Input Parameters:**
```javascript
aisleId: number
rackData = {
  rack_code: string,   // Unique identifier
  bays: number,        // Number of bays (default: 5)
  levels: number,      // Number of levels (default: 4)
  bins: number         // Bins per level (default: 3)
}
```

**Validation Logic:**
```javascript
// Verify parent aisle exists
const aisle = await Aisle.getById(aisleId)
if (!aisle) throw new Error('Parent aisle not found')

// Validate rack_code
if (!rackData.rack_code || typeof rackData.rack_code !== 'string')
  throw new Error('Rack code must be non-empty string')

// Check for duplicate rack_code in same aisle
const existing = await Rack.findByAisleAndCode(aisleId, rackData.rack_code)
if (existing)
  throw new Error('Rack with this code already exists')

// Validate dimensions
const bays = parseInt(rackData.bays) || 5
const levels = parseInt(rackData.levels) || 4
const bins = parseInt(rackData.bins) || 3

if (bays < 1 || levels < 1 || bins < 1)
  throw new Error('Bays, levels, bins must be positive integers')

// Calculate total slots
const totalSlots = bays * levels * bins
if (totalSlots > 10000)  // Sanity check
  throw new Error('Total slots cannot exceed 10000')
```

**SQL Queries:**
```sql
-- 1. Create rack
INSERT INTO racks (parent_aisle, rack_code) 
VALUES (?, ?);
-- Parameters: [aisleId, rack_code]
-- Returns: rack_id

-- 2. Create slots (bulk insert)
INSERT INTO rack_slots (rack_id, direction, bay_no, level_no, bin_no, capacity)
VALUES 
  (rack_id, 'left', 1, 1, 1, 100),
  (rack_id, 'left', 1, 1, 2, 100),
  (rack_id, 'right', 1, 1, 1, 100),
  ...
-- Repeat for all bays × levels × bins combinations
-- Each slot gets alternating direction (left/right) per bay
```

**Response Data:**
```javascript
{
  rack_id: number,
  parent_aisle: number,
  rack_code: string,
  total_slots: number,     // bays × levels × bins
  slots_created: number,   // Total slots created
  created_at: Date
}
```

---

## RACK SLOTS SERVICE

### getAllSlotsByRack(rackId, page, limit, filters)
Fetches slots for a rack with optional filters.

**Input Parameters:**
```javascript
rackId: number
page: number = 1
limit: number = 10
filters = {
  occupied: boolean | undefined,    // true/false
  direction: string | undefined,    // "left" or "right"
  capacity_min: number | undefined
}
```

**SQL Query Generated:**
```sql
SELECT 
  rs.slot_id,
  rs.rack_id,
  rs.direction,
  rs.bay_no,
  rs.level_no,
  rs.bin_no,
  rs.capacity,
  rs.is_occupied,
  ROUND((s.quantity / rs.capacity) * 100) as occupancy_percentage,
  s.stock_id,
  p.name as product_name,
  s.quantity,
  rs.created_at
FROM rack_slots rs
LEFT JOIN stocks s ON rs.slot_id = s.slot_id
LEFT JOIN products p ON s.product_id = p.product_id
WHERE rs.rack_id = ?
  AND (? IS NULL OR rs.is_occupied = ?)
  AND (? IS NULL OR rs.direction = ?)
  AND (? IS NULL OR rs.capacity >= ?)
ORDER BY rs.bay_no, rs.level_no, rs.bin_no
LIMIT ? OFFSET ?;
```

**Response Data:**
```javascript
{
  slots: [
    {
      slot_id: number,
      rack_id: number,
      direction: "left" | "right",
      bay_no: number,
      level_no: number,
      bin_no: number,
      capacity: number,
      is_occupied: boolean,
      occupancy_percentage: number,
      stock_id: number | null,
      product_name: string | null,
      product_id: number | null,
      quantity: number | null,
      created_at: Date
    },
    ...
  ],
  pagination: {
    page: number,
    limit: number,
    total: number,
    pages: number
  }
}
```

---

## SCHEMA UTILIZATION SERVICE

### getSchemaUtilization(locationId)
Calculates detailed utilization metrics for entire location.

**SQL Query:**
```sql
SELECT 
  l.location_id,
  l.name,
  COUNT(DISTINCT d.depot_id) as total_depots,
  COUNT(DISTINCT a.aisle_id) as total_aisles,
  COUNT(DISTINCT r.rack_id) as total_racks,
  COUNT(DISTINCT rs.slot_id) as total_slots,
  SUM(CASE WHEN rs.is_occupied = 1 THEN 1 ELSE 0 END) as occupied_slots,
  (
    COUNT(DISTINCT rs.slot_id) - 
    SUM(CASE WHEN rs.is_occupied = 1 THEN 1 ELSE 0 END)
  ) as empty_slots,
  ROUND(
    (SUM(CASE WHEN rs.is_occupied = 1 THEN 1 ELSE 0 END) / 
     COUNT(DISTINCT rs.slot_id)) * 100
  ) as utilization_percentage
FROM locations l
LEFT JOIN depots d ON l.location_id = d.parent_location
LEFT JOIN aisles a ON d.depot_id = a.parent_depot
LEFT JOIN racks r ON a.aisle_id = r.parent_aisle
LEFT JOIN rack_slots rs ON r.rack_id = rs.rack_id
WHERE l.location_id = ?
GROUP BY l.location_id;
```

**Response Data:**
```javascript
{
  location_id: number,
  location_name: string,
  total_depots: number,
  total_aisles: number,
  total_racks: number,
  total_slots: number,
  occupied_slots: number,
  empty_slots: number,
  utilization_percentage: number,
  
  // Per-depot breakdown
  depots: [
    {
      depot_id: number,
      name: string,
      utilization_percentage: number,
      aisles_count: number,
      total_slots: number,
      occupied_slots: number
    },
    ...
  ]
}
```

---

## Error Handling Patterns

```javascript
try {
  // Validation
  if (!validCondition) throw new Error('Validation message')
  
  // Model call
  const result = await Model.method(params)
  
  // Transformation
  const formatted = transform(result)
  
  // Return
  return formatted
  
} catch (error) {
  // Log for debugging
  console.error('Service error:', error.message)
  
  // Re-throw for controller error handler
  throw new Error(error.message)
}
```

All services follow this pattern for consistency and maintainability.
