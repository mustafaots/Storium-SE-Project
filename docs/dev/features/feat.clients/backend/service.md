# Clients Service

## Purpose
Implements business logic for client management. Handles pagination, search validation, data transformation, and orchestrates communication between controllers and models.

## File Location
`backend/src/services/clients.service.js`

---

## Methods

### getAllPaginated(page, limit, search)
Fetches paginated clients with search capability.

**Input Parameters:**
```javascript
page: number = 1           // Page number (1-based, minimum 1)
limit: number = 10         // Items per page (1-100)
search: string = ""        // Search term
```

**Validation Logic:**
```javascript
// Validate page
validatedPage = Math.max(1, parseInt(page))
if (isNaN(validatedPage)) validatedPage = 1

// Validate limit
validatedLimit = Math.min(
  Math.max(1, parseInt(limit)),
  constants.PAGINATION.MAX_LIMIT  // Typically 100
)
if (isNaN(validatedLimit)) validatedLimit = 10

// Trim search
search = search.trim()
```

**SQL Queries Generated:**
```sql
-- Without search:
SELECT * FROM clients 
ORDER BY created_at DESC 
LIMIT 10 OFFSET 0;

-- With search (e.g., 'acme'):
SELECT * FROM clients
WHERE client_name LIKE '%acme%' 
   OR contact_email LIKE '%acme%' 
   OR contact_phone LIKE '%acme%'
   OR address LIKE '%acme%'
ORDER BY created_at DESC
LIMIT 10 OFFSET 0;
```

**Parallel Execution:**
```javascript
const [clients, total] = await Promise.all([
  Client.getAllPaginated(validatedPage, validatedLimit, search),
  Client.getTotalCount(search)
])
```

**Response Data:**
```javascript
{
  clients: [
    {
      client_id: number,
      client_name: string,
      contact_email: string | null,
      contact_phone: string | null,
      address: string | null,
      created_at: Date
    },
    ...
  ],
  pagination: {
    page: number,
    limit: number,
    total: number,        // Total matching records
    pages: number         // Math.ceil(total / limit)
  }
}
```

**Error Handling:**
```javascript
if (err) throw new Error('Database query failed')
if (page < 1) throw new Error('Page must be >= 1')
if (limit < 1) throw new Error('Limit must be >= 1')
```

---

### getById(id)
Fetches a single client by ID.

**Input Parameters:**
```javascript
id: number  // Client ID
```

**SQL Query:**
```sql
SELECT * FROM clients WHERE client_id = ?;
-- Parameters: [id]
```

**Response Data:**
```javascript
{
  client_id: number,
  client_name: string,
  contact_email: string | null,
  contact_phone: string | null,
  address: string | null,
  created_at: Date
} | undefined  // undefined if not found
```

---

### create(clientData)
Creates a new client.

**Input Parameters:**
```javascript
clientData = {
  client_name: string,              // Required
  contact_email: string | null,     // Optional
  contact_phone: string | null,     // Optional
  address: string | null            // Optional
}
```

**Validation Rules:**
```javascript
// Validate presence
if (!client_name || typeof client_name !== 'string')
  throw new Error('client_name is required and must be string')

if (client_name.trim().length === 0)
  throw new Error('client_name cannot be empty')

// Validate email format (if provided)
if (contact_email) {
  const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  if (!emailPattern.test(contact_email))
    throw new Error('Invalid email format')
}

// Validate phone format (if provided)
if (contact_phone) {
  const phonePattern = /^[0-9\-\+\(\)\s]+$/
  if (!phonePattern.test(contact_phone))
    throw new Error('Invalid phone format')
}
```

**SQL Query:**
```sql
INSERT INTO clients (client_name, contact_email, contact_phone, address)
VALUES (?, ?, ?, ?);
-- Parameters: [client_name, contact_email, contact_phone, address]

-- Auto-generated:
-- client_id: INT AUTO_INCREMENT
-- created_at: TIMESTAMP DEFAULT CURRENT_TIMESTAMP
```

**Response Data:**
```javascript
{
  client_id: number,    // Generated by AUTO_INCREMENT
  client_name: string,
  contact_email: string | null,
  contact_phone: string | null,
  address: string | null,
  created_at: Date
}
```

---

### update(id, clientData)
Updates an existing client.

**Input Parameters:**
```javascript
id: number
clientData = {
  client_name: string | undefined,
  contact_email: string | null | undefined,
  contact_phone: string | null | undefined,
  address: string | null | undefined
}
```

**Validation Logic:**
```javascript
// Check if ID is valid
if (!id || isNaN(id)) throw new Error('Valid ID required')

// Validate only fields being updated
const updates = {}

if (clientData.client_name !== undefined) {
  if (typeof clientData.client_name !== 'string')
    throw new Error('client_name must be string')
  updates.client_name = clientData.client_name
}

if (clientData.contact_email !== undefined) {
  if (clientData.contact_email !== null) {
    const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    if (!emailPattern.test(clientData.contact_email))
      throw new Error('Invalid email format')
  }
  updates.contact_email = clientData.contact_email
}

// Similar validation for phone and address...
```

**SQL Query Generated:**
```sql
UPDATE clients 
SET client_name = ?, contact_email = ?, contact_phone = ?, address = ?
WHERE client_id = ?;
-- Parameters: [client_name, contact_email, contact_phone, address, id]
```

**Response Data:**
```javascript
{
  affectedRows: number,   // 0 if not found, 1 if updated
  changedRows: number,    // 1 if data actually changed
  message: string
}
```

---

### delete(id)
Deletes a client.

**Input Parameters:**
```javascript
id: number  // Client ID
```

**SQL Query:**
```sql
DELETE FROM clients WHERE client_id = ?;
-- Parameters: [id]
```

**Cascade Behavior:**
```
DELETE FROM clients WHERE client_id = 5
  ↓
Foreign keys in transactions:
  FOREIGN KEY (client_id) REFERENCES clients(client_id) ON DELETE SET NULL
  
Result: Client deleted, but transactions remain with client_id = NULL
```

**Response Data:**
```javascript
{
  affectedRows: number,   // 1 if deleted, 0 if not found
  message: string
}
```

---

## Database Schema

```sql
CREATE TABLE clients (
    client_id INT AUTO_INCREMENT PRIMARY KEY,
    client_name VARCHAR(255) NOT NULL COMMENT 'Client name (e.g., company name)',
    contact_email VARCHAR(255) COMMENT 'Email address',
    contact_phone VARCHAR(50) COMMENT 'Phone number',
    address TEXT COMMENT 'Physical address',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_client_name (client_name),
    INDEX idx_contact_email (contact_email),
    INDEX idx_contact_phone (contact_phone)
);
```

**Column Specifications:**
- `client_id`: Auto-incrementing primary key
- `client_name`: VARCHAR(255) - Company/client name (NOT NULL)
- `contact_email`: VARCHAR(255) - Email (allows NULL)
- `contact_phone`: VARCHAR(50) - Phone (allows NULL)
- `address`: TEXT - Full address (allows NULL)
- `created_at`: TIMESTAMP - Auto-set to current time

---

## Search Implementation

The search functionality scans multiple fields:

```javascript
Search fields: ['client_name', 'contact_email', 'contact_phone', 'address']

SQL generated:
WHERE client_name LIKE '%searchTerm%'
   OR contact_email LIKE '%searchTerm%'
   OR contact_phone LIKE '%searchTerm%'
   OR address LIKE '%searchTerm%'
```

**Search Examples:**
- Search "acme" → finds "Acme Corp", "acme.com", etc.
- Search "555-0100" → finds phone number matches
- Search "city" → finds addresses containing "city"

---

## Error Handling Patterns

```javascript
try {
  // Validation
  if (!validCondition) throw new Error('Validation message')
  
  // Model call
  const result = await Client.method(params)
  
  // Transformation
  const formatted = transform(result)
  
  // Return
  return formatted
  
} catch (error) {
  // Log for debugging
  console.error('Service error:', error.message)
  
  // Re-throw for controller error handler
  throw new Error(error.message)
}
```

All services follow this pattern for consistent error handling and maintainability.
